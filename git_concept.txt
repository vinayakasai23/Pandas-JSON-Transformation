1. If you use 'rm' then it will be removed from both the file system and .git folder, then if you want to commit the changes you have to add to the staging area and commit the changes then it will be deleted from both file system and .git as well.
2. If you use 'git rm' then it will be removed from both the file system and .git folder just like the above statement, but after deletion it will automatically adds to the staging area without need to add it separately, you just need to commit the deletion changes.
3. If you use 'git rm --cached' then it won't be removed from the file system, it will be removed from .git folder and automatically adds to the staging area, you just need to commit the deletion changes.
4. If you want to untrack the existing tracking files just use the above 'git rm --cached' so that it won't be deleted but will be deleted from the .git folder which untracks the existing one.
5. If you accidentally staged the file after modification, you can unstage using 'git restore --staged <filename>' as suggested in the git bash.
6. 'git diff' compares the current changes to the last committed staged code. If you have staged your current files, and you want to compare the changes to the last committed staged code, then use 'git diff --staged'.
7. If you made any big mistake in the existing file, and you want to go back to the last working commit, use 'git checkout <filename>'.
8. If you completely want to move to the last commit, you can use 'git checkout -f', it will completely delete your existing changes and moves back to the last working commit.
9. If you want to create a new branch, use 'git branch <branch name>', If you want to create a new branch and want to checkout use 'git checkout -b <branch name>'.
10. Once you have modified the file in a branch, you cannot checkout to the other branch until it is committed. Once you have committed the changes you can checkout to other branches.
11. After merging is done with other branch, if you want to delete the unwanted branch you can use 'git branch -d <branch name>', but if you did not do any merging and your branch code is useless then if you want to delete the branch, use 'git branch -D <branch name>'.
12. You cannot delete the current working branch, if you want to delete the current working branch, first checkout to any of the other branches and perform 'git branch -D/-d(as required) <branch name>' to delete the branch.
13. If two separate branches b1&b2 are created from the master branch and both the developers from both the branches are working on the same file, then if you tried to merge both the branches b1&b2 you will get merge conflict, i.e. you cannot merge both the branches. To resolve the merge conflict, remove/modify the changes in one of the branches, stage the changes and commit them to resolve the merge conflict. Once you ran 'git commit' after modification, the merge will happen automatically.
14. If you want to merge master with branch(b), then first checkout to the master and perform 'git merge b', then merge happens.
15. For rebasing to happen, first checkout to the current branch to perform the rebasing onto other branch. For example to rebase b&master, first checkout to branch b, then rebase to master so that all the commits of branch b will be committed to master branch linearly.
16. Rebasing - If a branch(b) is created from the master branch then if you perform rebasing means - 1. git first goes to the mutual parent commit and records the differences of each commits of branch b to some temporary file, then 2. the branch(b) pointer points to the master's latest commit and deletes the entire branch b, Now, both master&b points to the same latest commit of master then 3. each recorded changes of commits of branch b will be committed to the master's latest commit each at a time and forms a linear commits of master and branch b, then 4. the branch(b) pointer moves from the master to the latest affected commit. Then, rebasing is done.
17. If you want the master to point to the last commit as well then do the merge between master and latest commit the branch(b) pointing to. i.e. 'git merge b'.
18. If an open source code looks like a 'master+important branch' and some of the collaborators are working on the imp.branch and others might create a separate branch on the imp.branch, if you do rebase then other persons branches might affect, because now if points onto somewhere on the base branch, so be careful while using rebasing until somebody wants a pure linear development like a story mode.